软件中有一些功能，需要运用到应用程序中很多地方，但有不想在每一个点都明确的调用它
日志，安全和事务管理很重要，但是否应用对象应该主动参与这些行为，还是应用只是注重自己的业务逻辑，这些日志、安全和事务管理只是被动的进行。
常见的应用案例是，日志，安全，声明式事务，缓存

AspectJ——另一种流行的AOP，可以补充Spring AOP框架，功能强于Spring AOP框架

具体详情理解：http://blog.csdn.net/qukaiwei/article/details/50367761

1. 通知（Advice），就是功能比如说日志、安全、事务和缓存，你定义好，等哪个地方想用就用那里去，相当于申明一些功能

2. 连接点（JoinPoint），就是spring允许使用通知的地方，每一个方法的前后和抛异常时(Spring只支持方法的连接点，AspectJ还支持构造器和属性注入时)

3. 切点（PointCut），通过切点（切入点）来找出（筛选出）哪些连接点使用通知，切点的作用是检索的功能，找到需要应用通知的连接点

4. 切面（Aspect），通知和切点的结合，并不需要所有的连接点，通知是要干什么，切点是在哪里干

5. 引入（introduction），其实和通知类似，通知的功能是增强补充核心业务的功能，而引入的概念是在不入侵核心业务类的情况下，往核心业务类中添加新的 introductionNotice 
        包下有演示

6. 目标（target），目标类，被通知的对象，只关注自己的业务逻辑，在没有被发现的情况下被织入切面

7. 织入（weaving）, 切面和应用的目标 来创建代理对象的过程，调用核心业务方法时，其实先要通过代理，代理处理一些日志等通知业务，再处理核心业务，有三种方式生成代理

8. 代理（proxy），spring的AOP是通过代理实现的

Spring的AOP实现
	因为不想方法的核心业务被日志等操作侵入，要想实现非侵入式的日志等业务，原核心业务类是满足不了的，所以需要一个类，既包含核心业务的功能，又要包含且切面功能，这个就是代理类。
用这个代理类来伪装成目标类，所有的对目标类的操作都转接到代理类中，在这里，由代理类来处理通知，再调用转发给真正的目标类。
	具体理解，可以看  http://blog.csdn.net/qukaiwei/article/details/50367761 文章，写的很好
	代码演示部分 ：   staticProxy包下是，静态代理，原理理解
			    interfaceProxy包下，动态代理，基于接口的代理
			    cglibProxy包下，动态代理，基于类

